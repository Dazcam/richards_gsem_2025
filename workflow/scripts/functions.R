## BiomaRt
require(biomaRt)
require(tidyverse)

download_supercluster_spec_scores <- function(dest_dir) {
  #' Download Siletti 2024 Supercluster Specificity Scores
  #' 
  #' This function downloads the supercluster specificity scores from Siletti 2024, 
  #' generated by Yao et al. 2025, as published in Nature Communications.
  #' 
  #' Paper link: https://www.nature.com/articles/s41467-024-55611-1#Sec50
  #' 
  #' The function:
  #' - Checks if the `dest_dir` directory exists, creating it if needed.
  #' - Validates the download URL.
  #' - Downloads and extracts the data only if it hasn't been already.
  #' 
  #' Data source:
  #' https://static-content.springer.com/esm/art%3A10.1038%2Fs41467-024-55611-1/MediaObjects/41467_2024_55611_MOESM4_ESM.zip
  
  library(httr)
  library(utils)
  
  url <- "https://static-content.springer.com/esm/art%3A10.1038%2Fs41467-024-55611-1/MediaObjects/41467_2024_55611_MOESM4_ESM.zip"
  
  zip_file <- file.path(dest_dir, "supercluster_spec_scores.zip")
  extracted_folder <- file.path(dest_dir, "Source_Data_v241210")
  
  # Create resources directory if it doesn't exist
  if (!dir.exists(dest_dir)) {
    dir.create(dest_dir, recursive = TRUE)
  }
  
  # Check if URL is accessible
  response <- HEAD(url)
  if (http_error(response)) {
    stop("Error: Unable to access the download link. Please check the URL.")
  }
  
  # Download ZIP file if not already present
  if (!file.exists(zip_file)) {
    message("Downloading supercluster specificity scores...")
    download.file(url, zip_file, mode = "wb")
  } else {
    message("ZIP file already exists. Skipping download.")
  }
  
  # Extract files if not already extracted
  if (!dir.exists(extracted_folder)) {
    message("Extracting ZIP file...")
    unzip(zip_file, exdir = dest_dir)
  } else {
    message("Data already extracted. Skipping extraction.")
  }
  
  message("Download and extraction complete.")
}

#' Get Gene Lookup Table from Ensembl Biomart
#' 
#' This function retrieves a gene lookup table from Ensembl's Biomart database for 
#' either the hg38 or hg19 genome builds. The lookup table contains key gene 
#' information, such as gene symbols, Ensembl IDs, chromosome locations, and biotypes.
#'
#' @param genome_build A string indicating the genome build to use. Options are:
#'   'hg38' (default) for the human genome build 38 or 'hg19' for build 19.
#' 
#' @return A tibble containing gene information from the selected genome build, including:
#'   - Chromosome name
#'   - Start and end positions
#'   - Gene biotype
#'   - HGNC symbol and ID
#'   - Entrez gene ID
#'   - Ensembl gene ID
#'   - Strand
#'   - External gene name (for hg38) or transcript information (for hg19).
#'
#' @examples
#' # Get gene lookup table for hg38
#' hg38_lookup <- get_biomart_gene_lookup('hg38')
#'
#' # Get gene lookup table for hg19
#' hg19_lookup <- get_biomart_gene_lookup('hg19')
#'
#' @export
get_biomart_gene_lookup <- function(genome_build = 'hg38') {
  
  if (genome_build == 'hg38') {
    
    # Get hg38 gene lookup table
    mart_hg38 <- useMart('ENSEMBL_MART_ENSEMBL')
    mart_hg38 <- useDataset('hsapiens_gene_ensembl', mart_hg38)
    
    attribs <- as_tibble(listAttributes(mart_hg38))
    
    annot_lookup <- as_tibble(
      getBM(
        mart = mart_hg38,
        attributes = c(
          'chromosome_name', 
          'start_position', 
          'end_position',       
          'gene_biotype', 
          'hgnc_symbol',
          'hgnc_id',
          'entrezgene_id', 
          'ensembl_gene_id',
          'strand',
          'external_gene_name'),
        uniqueRows = TRUE))
    
  }
  
  if (genome_build == 'hg19') {
    
    mart_hg19 <- useMart('ENSEMBL_MART_ENSEMBL', host = 'https://grch37.ensembl.org')
    mart_hg19 <- useDataset('hsapiens_gene_ensembl', mart_hg19)
    
    annot_lookup <- as_tibble(
      getBM(
        mart = mart_hg19,
        attributes = c(
          'chromosome_name', 
          'description',
          'start_position', 
          'end_position',       
          'gene_biotype', 
          'hgnc_symbol',
          'entrezgene_id', 
          'ensembl_gene_id',
          'strand',
          'transcript_gencode_basic'),
        uniqueRows = TRUE))
    
  }
  
  return(annot_lookup)
  
}